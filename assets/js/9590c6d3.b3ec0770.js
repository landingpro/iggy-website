"use strict";(self.webpackChunkiggy_website=self.webpackChunkiggy_website||[]).push([[90],{4170:e=>{e.exports=JSON.parse('{"permalink":"/blogs/2023/12/29/building-message-streaming-in-rust","source":"@site/blog/2023-12-29-building-message-streaming-in-rust.md","title":"Iggy.rs - building message streaming in Rust","description":"Origins","date":"2023-12-29T00:00:00.000Z","tags":[],"readingTime":12.345,"hasTruncateMarker":true,"authors":[{"name":"Piotr Gankiewicz","title":"Apache Iggy founder","url":"https://github.com/spetz","socials":{},"key":null,"page":null}],"frontMatter":{"title":"Iggy.rs - building message streaming in Rust","authors":[{"name":"Piotr Gankiewicz","title":"Apache Iggy founder","url":"https://github.com/spetz"}],"tags":[],"hide_table_of_contents":false,"date":"2023-12-29T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Iggy.rs \u2014 one year of building the message streaming","permalink":"/blogs/2024/05/29/one-year-of-building-the-message-streaming"},"nextItem":{"title":"Iggy 0.1.0 release","permalink":"/blogs/iggy-0-1-0-release"}}')},7352:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>g});var n=s(4170),i=s(4848),r=s(8453);const a={title:"Iggy.rs - building message streaming in Rust",authors:[{name:"Piotr Gankiewicz",title:"Apache Iggy founder",url:"https://github.com/spetz"}],tags:[],hide_table_of_contents:!1,date:new Date("2023-12-29T00:00:00.000Z")},o=void 0,l={authorsImageUrls:[void 0]},g=[{value:"Origins",id:"origins",level:2}];function c(e){const t={a:"a",h2:"h2",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"origins",children:"Origins"}),"\n",(0,i.jsxs)(t.p,{children:["Over half a year ago (in April, to be exact), I eventually decided to learn Rust for good. My previous attempt during the ",(0,i.jsx)(t.a,{href:"https://github.com/spetz/advent-of-code-2022",children:"2022 AoC"})," had failed rather quickly, after a few days of completing the exercises - I finally realized that ",(0,i.jsx)(t.strong,{children:"I needed a real project to work on"}),". For the last few years, I've been dealing with the different kinds of distributed systems (mostly using C#), including the typical microservices architecture or Web3. Regardless of their nature, some sort of the messaging between the independent components was always required. I had a chance to use the tools such as ",(0,i.jsx)(t.a,{href:"https://rabbitmq.com",children:"RabbitMQ"}),", ",(0,i.jsx)(t.a,{href:"https://zeromq.org",children:"ZeroMQ"}),", ",(0,i.jsx)(t.a,{href:"https://kafka.apache.org",children:"Kafka"})," or ",(0,i.jsx)(t.a,{href:"https://aeron.io",children:"Aeron"})," (just to name a few), as well as implementing the low-level peer-to-peer communication ",(0,i.jsx)(t.a,{href:"https://libp2p.io",children:"protocols"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(6540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);