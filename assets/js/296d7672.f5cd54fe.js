"use strict";(self.webpackChunkiggy_website=self.webpackChunkiggy_website||[]).push([[4906],{6057:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>u,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var s=r(9603),t=r(4848),i=r(8453);const o={title:"Consumer identifier",slug:"consumer-identifier",authors:[{name:"Piotr Gankiewicz",title:"Apache Iggy founder",url:"https://github.com/spetz"}],tags:["new-features","consumers","identifier"],hide_table_of_contents:!1},u=void 0,c={authorsImageUrls:[void 0]},d=[{value:"Breaking changes",id:"breaking-changes",level:2},{value:"Consumer identifier",id:"consumer-identifier",level:2},{value:"Consumer groups",id:"consumer-groups",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["In the latest update, the Iggy server as well as the clients for all the available transport protocols have been extended with the support for ",(0,t.jsx)(n.strong,{children:"consumer identifier"}),". Whether you poll the messages, store the consumer offsets, or create consumer groups, you can use the well-established ",(0,t.jsx)(n.code,{children:"identifier"})," type, instead of just ",(0,t.jsx)(n.code,{children:"u32"}),", which is now a common standard for the resources' identification such as streams, topics, users and consumers."]}),"\n",(0,t.jsx)(n.h2,{id:"breaking-changes",children:"Breaking changes"}),"\n",(0,t.jsxs)(n.p,{children:["The breaking changes have been introduced in Iggy server, starting from version ",(0,t.jsx)(n.code,{children:"0.0.30"})," and Iggy SDK, starting from version ",(0,t.jsx)(n.code,{children:"0.0.90"}),". The final commit containing all the mentioned changes is ",(0,t.jsx)(n.a,{href:"https://github.com/apache/iggy/commit/655f9b6bccb0ae4148422f32475a9bedc09827d2",children:"#655f9b6"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"consumer-identifier",children:"Consumer identifier"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct Consumer {\n    pub kind: ConsumerKind,\n    pub id: Identifier,\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["All the commands, such as ",(0,t.jsx)(n.code,{children:"PollMessages"}),", ",(0,t.jsx)(n.code,{children:"StoreConsumerOffset"})," and ",(0,t.jsx)(n.code,{children:"GetConsumerOffset"})," which contain the ",(0,t.jsx)(n.code,{children:"consumer"})," field, now require an update to the underlying serialization, as the ",(0,t.jsx)(n.code,{children:"id"})," field is now an ",(0,t.jsx)(n.code,{children:"Identifier"})," type, instead of ",(0,t.jsx)(n.code,{children:"u32"}),". The serialization is the same, as when working with the ",(0,t.jsx)(n.code,{children:"stream"}),", ",(0,t.jsx)(n.code,{children:"topic"})," or ",(0,t.jsx)(n.code,{children:"user"})," resources."]}),"\n",(0,t.jsxs)(n.p,{children:["From now on, whenever working with the ",(0,t.jsx)(n.code,{children:"consumer"})," or ",(0,t.jsx)(n.code,{children:"consumer group"})," resource, you can use the numeric or text identifier."]}),"\n",(0,t.jsx)(n.h2,{id:"consumer-groups",children:"Consumer groups"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct CreateConsumerGroup {\n    pub stream_id: Identifier,\n    pub topic_id: Identifier,\n    pub consumer_group_id: u32,\n    pub name: String,\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When creating the consumer group, the required ",(0,t.jsx)(n.code,{children:"name"})," field has been added (must be ",(0,t.jsx)(n.strong,{children:"unique per topic"}),"), and is serialized as usual, at the end of the payload, starting with the ",(0,t.jsx)(n.code,{children:"name length"})," (4 bytes) and the ",(0,t.jsx)(n.code,{children:"name"})," itself (N bytes)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct DeleteConsumerGroup {\n    pub stream_id: Identifier,\n    pub topic_id: Identifier,\n    pub consumer_group_id: Identifier,\n}\n\npub struct GetConsumerGroup {\n    pub stream_id: Identifier,\n    pub topic_id: Identifier,\n    pub consumer_group_id: Identifier,\n}\n\npub struct JoinConsumerGroup {\n    pub stream_id: Identifier,\n    pub topic_id: Identifier,\n    pub consumer_group_id: Identifier,\n}\n\npub struct LeaveConsumerGroup {\n    pub stream_id: Identifier,\n    pub topic_id: Identifier,\n    pub consumer_group_id: Identifier,\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"DeleteConsumerGroup"}),", ",(0,t.jsx)(n.code,{children:"GetConsumerGroup"}),", ",(0,t.jsx)(n.code,{children:"JoinConsumerGroup"})," and ",(0,t.jsx)(n.code,{children:"LeaveConsumerGroup"})," commands have been extended with the ",(0,t.jsx)(n.code,{children:"consumer_group_id"})," field, which is now an ",(0,t.jsx)(n.code,{children:"Identifier"})," type, instead of ",(0,t.jsx)(n.code,{children:"u32"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct ConsumerGroup {\n    pub id: u32,\n    pub name: String,\n    pub partitions_count: u32,\n    pub members_count: u32,\n}\n\npub struct ConsumerGroupDetails {\n    pub id: u32,\n    pub name: String,\n    pub partitions_count: u32,\n    pub members_count: u32,\n    pub members: Vec<ConsumerGroupMember>,\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When fetching the consumer group(s), the ",(0,t.jsx)(n.code,{children:"ConsumerGroup"})," and ",(0,t.jsx)(n.code,{children:"ConsumerGroupDetails"})," structs have been extended with the ",(0,t.jsx)(n.code,{children:"name"})," field, which serialized after ",(0,t.jsx)(n.code,{children:"members_count"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>u});var s=r(6540);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},9603:e=>{e.exports=JSON.parse('{"permalink":"/blogs/consumer-identifier","source":"@site/blog/2023-10-02-consumer-identifier.md","title":"Consumer identifier","description":"In the latest update, the Iggy server as well as the clients for all the available transport protocols have been extended with the support for consumer identifier. Whether you poll the messages, store the consumer offsets, or create consumer groups, you can use the well-established identifier type, instead of just u32, which is now a common standard for the resources\' identification such as streams, topics, users and consumers.","date":"2023-10-02T00:00:00.000Z","tags":[{"inline":true,"label":"new-features","permalink":"/blogs/tags/new-features"},{"inline":true,"label":"consumers","permalink":"/blogs/tags/consumers"},{"inline":true,"label":"identifier","permalink":"/blogs/tags/identifier"}],"readingTime":1.955,"hasTruncateMarker":true,"authors":[{"name":"Piotr Gankiewicz","title":"Apache Iggy founder","url":"https://github.com/spetz","socials":{},"key":null,"page":null}],"frontMatter":{"title":"Consumer identifier","slug":"consumer-identifier","authors":[{"name":"Piotr Gankiewicz","title":"Apache Iggy founder","url":"https://github.com/spetz"}],"tags":["new-features","consumers","identifier"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Personal access tokens","permalink":"/blogs/personal-access-tokens"},"nextItem":{"title":"Users and permissions","permalink":"/blogs/users-and-permissions"}}')}}]);