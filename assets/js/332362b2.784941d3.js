"use strict";(self.webpackChunkiggy_website=self.webpackChunkiggy_website||[]).push([[2244],{5849:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"server/server-configuration","title":"Configuration","description":"The configuration can be found in server.toml file in configs directory. The config file is loaded from the current working directory, but you can specify the path to the configuration file by setting IGGYCONFIGPATH environment variable, for example export IGGYCONFIGPATH=configs/server.toml (or other command depending on OS). You can also provide the .env file in order to override the configuration - the convention is to use IGGY prefix for the environment variables e.g. IGGYHTTP_ENABLED=true.","source":"@site/docs/server/configuration.md","sourceDirName":"server","slug":"/server/configuration","permalink":"/docs/server/configuration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"server-configuration","slug":"/server/configuration","title":"Configuration","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/server/introduction"},"next":{"title":"Docker","permalink":"/docs/server/docker"}}');var i=t(4848),r=t(8453);const a={id:"server-configuration",slug:"/server/configuration",title:"Configuration",sidebar_position:2},o=void 0,c={},l=[{value:"HTTP",id:"http",level:3},{value:"TCP",id:"tcp",level:3},{value:"QUIC",id:"quic",level:3}];function d(e){const n={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The configuration can be found in ",(0,i.jsx)(n.code,{children:"server.toml"})," file in ",(0,i.jsx)(n.code,{children:"configs"})," directory. The config file is loaded from the current working directory, but you can specify the path to the configuration file by setting ",(0,i.jsx)(n.code,{children:"IGGY_CONFIG_PATH"})," environment variable, for example ",(0,i.jsx)(n.code,{children:"export IGGY_CONFIG_PATH=configs/server.toml"})," (or other command depending on OS). You can also provide the ",(0,i.jsx)(n.code,{children:".env"})," file in order to override the configuration - the convention is to use ",(0,i.jsx)(n.code,{children:"IGGY_"})," prefix for the environment variables e.g. ",(0,i.jsx)(n.code,{children:"IGGY_HTTP_ENABLED=true"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In case no configuration file is found, the server will use the default configuration."}),"\n",(0,i.jsx)(n.p,{children:"Let's take a look at the configuration file, and discuss the available options."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[data_maintenance.archiver]\n# Enables or disables the archiver process.\nenabled = false\n\n# Kind of archiver to use. Available options: "disk".\nkind = "disk"\n\n[data_maintenance.archiver.disk]\n# Path for storing the archived data on disk.\npath = "local_data/archive"\n\n[data_maintenance.archiver.s3]\n# Access key ID for the S3 bucket.\nkey_id = "123"\n\n# Secret access key for the S3 bucket\nkey_secret = "secret"\n\n# Name of the S3 bucket.\nbucket = "iggy"\n\n# Endpoint of the S3 region.\nendpoint = "http://localhost:9000"\n\n# Region of the S3 bucket.\nregion = "eu-west-1"\n\n# Temporary directory for storing the data before uploading to S3.\ntmp_upload_dir = "local_data/s3_tmp"\n\n[data_maintenance.messages]\n# Enables or disables the archiver process for closed segments containing messages.\narchiver_enabled = false\n\n# Enables or disables the expired message cleaner process.\ncleaner_enabled = false\n\n# Interval for running the message archiver and cleaner.\ninterval = "1 m"\n\n[data_maintenance.state]\n# Enables or disables the archiver process for state log.\narchiver_enabled = false\n\n# Sets whether the state archiver should overwrite existing log archive or always create a new one.\noverwrite = true\n\n# Interval for running the state archiver\ninterval = "1 m"\n\n# HTTP server configuration\n[http]\n# Determines if the HTTP server is active.\n# `true` enables the server, allowing it to handle HTTP requests.\n# `false` disables the server, preventing it from handling HTTP requests.\nenabled = true\n\n# Specifies the network address and port for the HTTP server.\n# The format is "HOST:PORT". For example, "0.0.0.0:3000" listens on all network interfaces on port 3000.\naddress = "0.0.0.0:3000"\n\n# Maximum size of the request body in bytes. For security reasons, the default limit is 2 MB.\nmax_request_size = "2 MB"\n\n# Configuration for Cross-Origin Resource Sharing (CORS).\n[http.cors]\n# Controls whether CORS is enabled for the HTTP server.\n# `true` allows handling cross-origin requests with specified rules.\n# `false` blocks cross-origin requests, enhancing security.\nenabled = true\n\n# Specifies which HTTP methods are allowed when CORS is enabled.\n# For example, ["GET", "POST"] would allow only GET and POST requests.\nallowed_methods = ["GET", "POST", "PUT", "DELETE"]\n\n# Defines which origins are permitted to make cross-origin requests.\n# An asterisk "*" allows all origins. Specific domains can be listed to restrict access.\nallowed_origins = ["*"]\n\n# Lists allowed headers that can be used in CORS requests.\n# For example, ["content-type"] permits only the content-type header.\nallowed_headers = ["content-type"]\n\n# Headers that browsers are allowed to access in CORS responses.\n# An empty array means no additional headers are exposed to browsers.\nexposed_headers = [""]\n\n# Determines if credentials like cookies or HTTP auth can be included in CORS requests.\n# `true` allows credentials to be included, useful for authenticated sessions.\n# `false` prevents credentials, enhancing privacy and security.\nallow_credentials = false\n\n# Allows or blocks requests from private networks in CORS.\n# `true` permits requests from private networks.\n# `false` disallows such requests, providing additional security.\nallow_private_network = false\n\n# JWT (JSON Web Token) configuration for HTTP.\n[http.jwt]\n# Specifies the algorithm used for signing JWTs.\n# For example, "HS256" indicates HMAC with SHA-256.\nalgorithm = "HS256"\n\n# The issuer of the JWT, typically a URL or an identifier of the issuing entity.\nissuer = "iggy.rs"\n\n# Intended audience for the JWT, usually the recipient or system intended to process the token.\naudience = "iggy.rs"\n\n# Lists valid issuers for JWT validation to ensure tokens are from trusted sources.\nvalid_issuers = ["iggy.rs"]\n\n# Lists valid audiences for JWT validation to confirm tokens are for the intended recipient.\nvalid_audiences = ["iggy.rs"]\n\n# Expiry time for access tokens.\naccess_token_expiry = "1 h"\n\n# Tolerance for timing discrepancies during token validation.\nclock_skew = "5 s"\n\n# Time before which the token should not be considered valid.\nnot_before = "0 s"\n\n# Secret key for encoding JWTs.\nencoding_secret = "top_secret$iggy.rs$_jwt_HS256_key#!"\n\n# Secret key for decoding JWTs.\ndecoding_secret = "top_secret$iggy.rs$_jwt_HS256_key#!"\n\n# Indicates if the secret key is base64 encoded.\n# `true` means the secret is base64 encoded.\n# `false` means the secret is in plain text.\nuse_base64_secret = false\n\n# Metrics configuration for HTTP.\n[http.metrics]\n# Enable or disable the metrics endpoint.\n# `true` makes metrics available at the specified endpoint.\n# `false` disables metrics collection.\nenabled = true\n\n# Specifies the endpoint for accessing metrics, e.g., "/metrics".\nendpoint = "/metrics"\n\n# TLS (Transport Layer Security) configuration for HTTP.\n[http.tls]\n# Controls the use of TLS for encrypted HTTP connections.\n# `true` enables TLS, enhancing security.\n# `false` disables TLS, which may be appropriate in secure internal networks.\nenabled = false\n\n# Path to the TLS certificate file.\ncert_file = "certs/iggy_cert.pem"\n\n# Path to the TLS key file.\nkey_file = "certs/iggy_key.pem"\n\n# TCP server configuration.\n[tcp]\n# Determines if the TCP server is active.\n# `true` enables the TCP server for handling TCP connections.\n# `false` disables it, preventing any TCP communication.\nenabled = true\n\n# Defines the network address and port for the TCP server.\n# For example, "0.0.0.0:8090" listens on all network interfaces on port 8090.\naddress = "0.0.0.0:8090"\n\n# Whether to use ipv4 or ipv6\nipv6 = false\n\n# TLS configuration for the TCP server.\n[tcp.tls]\n# Enables or disables TLS for TCP connections.\n# `true` secures TCP connections with TLS.\n# `false` leaves TCP connections unencrypted.\nenabled = false\n\n# Path to the TLS certificate for TCP.\ncertificate = "certs/iggy.pfx"\n\n# Password for the TLS certificate, required for accessing the private key.\npassword = "iggy123"\n\n# Configuration for the TCP socket\n[tcp.socket]\n# Whether to overwrite the OS-default socket parameters\noverride_defaults = false\n\n# SO_RCVBUF: maximum size of the receive buffer, can be clamped by the OS\nrecv_buffer_size = "100 KB"\n\n# SO_SNDBUF: maximum size of the send buffer, can be clamped by the OS\nsend_buffer_size = "100 KB"\n\n# SO_KEEPALIVE: whether to regularly send a keepalive packet maintaining the connection\nkeepalive = false\n\n# TCP_NODELAY: enable/disable the Nagle algorithm which buffers data before sending segments\nnodelay = false\n\n# SO_LINGER: delay to wait for while data is being transmitted before closing the socket after a\n# close or shutdown call has been received\nlinger = "0 s"\n\n# QUIC protocol configuration.\n[quic]\n# Controls whether the QUIC server is enabled.\n# `true` enables QUIC for fast, secure connections.\n# `false` disables QUIC, possibly for compatibility or simplicity.\nenabled = true\n\n# Network address and port for the QUIC server.\n# For example, "0.0.0.0:8080" binds to all interfaces on port 8080.\naddress = "0.0.0.0:8080"\n\n# Maximum number of simultaneous bidirectional streams in QUIC.\nmax_concurrent_bidi_streams = 10_000\n\n# Size of the buffer for sending datagrams in QUIC.\ndatagram_send_buffer_size = "100 KB"\n\n# Initial Maximum Transmission Unit (MTU) for QUIC connections.\ninitial_mtu = "8 KB"\n\n# Size of the sending window in QUIC, controlling data flow.\nsend_window = "100 KB"\n\n# Size of the receiving window in QUIC, controlling data flow.\nreceive_window = "100 KB"\n\n# Interval for sending keep-alive messages in QUIC.\nkeep_alive_interval = "5 s"\n\n# Maximum idle time before a QUIC connection is closed.\nmax_idle_timeout = "10 s"\n\n# QUIC certificate configuration.\n[quic.certificate]\n# Indicates whether the QUIC certificate is self-signed.\n# `true` for self-signed certificates, often used in internal or testing environments.\n# `false` for certificates issued by a certificate authority, common in production.\nself_signed = true\n\n# Path to the QUIC TLS certificate file.\ncert_file = "certs/iggy_cert.pem"\n\n# Path to the QUIC TLS key file.\nkey_file = "certs/iggy_key.pem"\n\n# Message cleaner configuration.\n[message_cleaner]\n# Enables or disables the background process for deleting expired messages.\n# `true` activates the message cleaner.\n# `false` turns it off, messages will not be auto-deleted based on expiry.\nenabled = true\n\n# Interval for running the message cleaner.\ninterval = "1 m"\n\n# Message saver configuration.\n[message_saver]\n# Enables or disables the background process for saving buffered data to disk.\n# `true` ensures data is periodically written to disk.\n# `false` turns off automatic saving, relying on other triggers for data persistence.\nenabled = true\n\n# Controls whether data saving is synchronous (enforce fsync) or asynchronous.\n# `true` for synchronous saving, ensuring data integrity at the cost of performance.\n# `false` for asynchronous saving, improving performance but with delayed data writing.\nenforce_fsync = true\n\n# Interval for running the message saver.\ninterval = "30 s"\n\n# Personal access token configuration.\n[personal_access_token]\n# Sets the maximum number of active tokens allowed per user.\nmax_tokens_per_user = 100\n\n# Personal access token cleaner configuration.\n[personal_access_token.cleaner]\n# Enables or disables the token cleaner process.\n# `true` activates periodic token cleaning.\n# `false` disables it, tokens remain active until manually revoked or expired.\nenabled = true\n\n# Interval for running the token cleaner.\ninterval = "1 m"\n\n# Heartbeat configuration\n[heartbeat]\n# Enables or disables the client heartbeat verification process.\nenabled = false\n# Interval for expected client heartbeats\ninterval = "5 s"\n\n# OpenTelemetry configuration\n[telemetry]\n# Enables or disables telemetry.\nenabled = false\n# Service name for telemetry.\nservice_name = "iggy"\n\n# OpenTelemetry logs configuration\n[telemetry.logs]\n# Transport for sending logs. Options: "grpc", "http".\ntransport = "grpc"\n# Endpoint for sending logs.\nendpoint = "http://localhost:7281/v1/logs"\n\n# OpenTelemetry traces configuration\n[telemetry.traces]\n# Transport for sending traces. Options: "grpc", "http".\ntransport = "grpc"\n# Endpoint for sending traces.\nendpoint = "http://localhost:7281/v1/traces"\n\n# System configuration.\n[system]\n# Base path for system data storage.\npath = "local_data"\n\n# Backup configuration\n[system.backup]\n# Path for storing backup.\npath = "backup"\n\n# Compatibility conversion configuration\n[system.backup.compatibility]\n# Subpath of the backup directory where converted segment data is stored after compatibility conversion.\npath = "compatibility"\n\n[system.state]\n# Determines whether to enforce file synchronization on state updates (boolean).\n# `true` ensures immediate writing of data to disk for durability.\n# `false` allows the OS to manage write operations, which can improve performance.\nenforce_fsync = false\n\n# Runtime configuration.\n[system.runtime]\n# Path for storing runtime data.\n# Specifies the directory where any runtime data is stored, relative to `system.path`.\npath = "runtime"\n\n# Logging configuration.\n[system.logging]\n# Path for storing log files.\npath = "logs"\n\n# Level of logging detail. Options: "debug", "info", "warn", "error".\nlevel = "info"\n\n# Maximum size of the log files before rotation.\nmax_size = "512 MB"\n\n# Time to retain log files before deletion.\nretention = "7 days"\n\n# Interval for printing system information to the log.\nsysinfo_print_interval = "10 s"\n\n# Cache configuration.\n[system.cache]\n# Enables or disables the system cache.\n# `true` activates caching for frequently accessed data.\n# `false` disables caching, data is always read from the source.\nenabled = true\n\n# Maximum size of the cache, e.g. "4GB".\nsize = "4 GB"\n\n# Encryption configuration\n[system.encryption]\n# Determines whether server-side data encryption for the messages payloads and state commands is enabled (boolean).\n# `true` enables encryption for stored data using AES-256-GCM.\n# `false` means data is stored without encryption.\nenabled = false\n\n# The encryption key used when encryption is enabled (string).\n# Should be a 32 bytes length key, provided as a base64 encoded string.\n# This key is required and used only if encryption is enabled.\nkey = ""\n\n# Compression configuration\n[system.compression]\n# Allows overriding the default compression algorithm per data segment (boolean).\n# `true` permits different compression algorithms for individual segments.\n# `false` means all data segments use the default compression algorithm.\nallow_override = false\n\n# The default compression algorithm used for data storage (string).\n# "none" indicates no compression, other values can specify different algorithms.\ndefault_algorithm = "none"\n\n# Stream configuration\n[system.stream]\n# Path for storing stream-related data (string).\n# Specifies the directory where stream data is stored, relative to `system.path`.\npath = "streams"\n\n# Topic configuration\n[system.topic]\n# Path for storing topic-related data (string).\n# Specifies the directory where topic data is stored, relative to `stream.path`.\npath = "topics"\n\n# Configures the topic size-based expiry setting.\n# "unlimited" or "0" means topics are kept indefinitely.\n# A size value in human-readable format determines the maximum size of a topic.\n# When a topic reaches this size, the oldest messages are deleted to make room for new ones.\n# Messages are removed in full segments, so if segment size is 1 GB and the topic size is 10 GB,\n# the oldest segment will be deleted upon reaching 10 GB.\n# Example: `max_topic_size = "10 GB"` means oldest messages in topics will be deleted when they reach 10 GB.\n# Note: this setting can be overwritten with CreateTopic and UpdateTopic requests.\nmax_size = "10 GB"\n\n# Configures whether the oldest segments are deleted when a topic reaches its maximum size (boolean).\ndelete_oldest_segments = false\n\n# Partition configuration\n[system.partition]\n# Path for storing partition-related data (string).\n# Specifies the directory where partition data is stored, relative to `topic.path`.\npath = "partitions"\n\n# Determines whether to enforce file synchronization on partition updates (boolean).\n# `true` ensures immediate writing of data to disk for durability.\n# `false` allows the OS to manage write operations, which can improve performance.\nenforce_fsync = false\n\n# Enables checksum validation for data integrity (boolean).\n# `true` activates CRC checks when loading data, guarding against corruption.\n# `false` skips these checks for faster loading at the risk of undetected corruption.\nvalidate_checksum = false\n\n# The threshold of buffered messages before triggering a save to disk (integer).\n# Specifies how many messages accumulate before persisting to storage.\n# Adjusting this can balance between write performance and data durability.\nmessages_required_to_save = 5000\n\n# Segment configuration\n[system.segment]\n# Defines the soft limit for the size of a storage segment.\n# When a segment reaches this size, a new segment is created for subsequent data.\n# Example: if `size` is set "1GB", the actual segment size may be 1GB + the size of remaining messages in received batch.\nsize = "1 GB"\n# Configures the message time-based expiry setting.\n# "none" means messages are kept indefinitely.\n# A time value in human-readable format determines the lifespan of messages.\n# Example: `message_expiry = "2 days 4 hours 15 minutes"` means messages will expire after that duration.\nmessage_expiry = "none"\n\n# Configures whether expired segments are archived (boolean) or just deleted without archiving.\narchive_expired = false\n\n# Controls whether to cache indexes (time and positional) for segment access (boolean).\n# `true` keeps indexes in memory, speeding up data retrieval.\n# `false` reads indexes from disk, which can conserve memory at the cost of access speed.\ncache_indexes = true\n\n# Message deduplication configuration\n[system.message_deduplication]\n# Controls whether message deduplication is enabled (boolean).\n# `true` activates deduplication, ignoring messages with duplicate IDs.\n# `false` treats each message as unique, even if IDs are duplicated.\nenabled = false\n# Maximum number of ID entries in the deduplication cache (u64).\nmax_entries = 1000\n# Maximum age of ID entries in the deduplication cache in human-readable format.\nexpiry = "1 m"\n\n# Recovery configuration in case of lost data\n[system.recovery]\n# Controls whether streams/topics/partitions should be recreated if the expected data for existing state is missing (boolean).\nrecreate_missing_state = true\n'})}),"\n",(0,i.jsx)(n.h3,{id:"http",children:"HTTP"}),"\n",(0,i.jsxs)(n.p,{children:["An optional transport layer, which can be used to connect to the server with any tool or application that supports HTTP. It is enabled by default, but you can disable it by setting ",(0,i.jsx)(n.code,{children:"enabled"})," to ",(0,i.jsx)(n.code,{children:"false"}),". The ",(0,i.jsx)(n.code,{children:"address"})," option specifies the address and port to listen on. The ",(0,i.jsx)(n.code,{children:"cors"})," section allows you to configure the CORS policy, which internally uses ",(0,i.jsx)(n.a,{href:"https://docs.rs/tower-http/latest/tower_http/cors/index.html",children:"Tower middleware"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["HTTP API is built on top of ",(0,i.jsx)(n.a,{href:"https://github.com/tokio-rs/axum",children:"Axum"})," and you can find all the available endpoints in ",(0,i.jsx)(n.a,{href:"https://github.com/apache/iggy/blob/master/core/server/server.http",children:"server.http"})," file, which can be used with ",(0,i.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=humao.rest-client",children:"REST Client"})," extension for VS Code."]}),"\n",(0,i.jsxs)(n.p,{children:["To consume the HTTP API from Iggy SDK, you need to make use of the available ",(0,i.jsx)(n.code,{children:"HttpClient"})," component."]}),"\n",(0,i.jsx)(n.p,{children:"HTTP API is highly performant, however, it's not as performant as TCP, and, since it's a stateless protocol, there's no such thing as the ongoing connection between client and server, thus some of the features such as consumer groups are not available."}),"\n",(0,i.jsx)(n.h3,{id:"tcp",children:"TCP"}),"\n",(0,i.jsxs)(n.p,{children:["An optional transport layer, which can be used to connect to the server with any tool or application that supports TCP. It is enabled by default, but you can disable it by setting ",(0,i.jsx)(n.code,{children:"enabled"})," to ",(0,i.jsx)(n.code,{children:"false"}),". The ",(0,i.jsx)(n.code,{children:"address"})," option specifies the address and port to listen on."]}),"\n",(0,i.jsx)(n.p,{children:"TCP provides the highest performance and throughput as it works directly with the binary data without an additional overhead of e.g. HTTP spec along with the JSON serialization."}),"\n",(0,i.jsxs)(n.p,{children:["To consume the TCP API from Iggy SDK, you need to make use of the available ",(0,i.jsx)(n.code,{children:"TcpClient"})," component."]}),"\n",(0,i.jsx)(n.h3,{id:"quic",children:"QUIC"}),"\n",(0,i.jsxs)(n.p,{children:["An optional transport layer, which can be used to connect to the server with any tool or application that supports QUIC. It is enabled by default, but you can disable it by setting ",(0,i.jsx)(n.code,{children:"enabled"})," to ",(0,i.jsx)(n.code,{children:"false"}),". The ",(0,i.jsx)(n.code,{children:"address"})," option specifies the address and port to listen on."]}),"\n",(0,i.jsxs)(n.p,{children:["Similar to TCP it's a stateful protocol, however, it's not as performant as TCP. QUIC support is built on top of ",(0,i.jsx)(n.a,{href:"https://github.com/quinn-rs/quinn",children:"Quinn"})," library, and all the remaining options are essentially the direct mapping of the options available in Quinn. QUIC and TCP use the same custom binary protocol specification."]}),"\n",(0,i.jsxs)(n.p,{children:["To consume the QUIC API from Iggy SDK, you need to make use of the available ",(0,i.jsx)(n.code,{children:"QuicClient"})," component."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);