"use strict";(self.webpackChunkiggy_website=self.webpackChunkiggy_website||[]).push([[1572],{737:e=>{e.exports=JSON.parse('{"permalink":"/blogs/message-state","source":"@site/blog/2023-08-22-message-state.md","title":"Message state","description":"The message state is a simple field which extends the existing message and provides a way to define whether the particular message might be consumed by the client or not, depending on its value. Let\'s briefly discuss the motivation behind this feature, the implementation details and the breaking changes introduced by this release.","date":"2023-08-22T00:00:00.000Z","tags":[{"inline":true,"label":"new-features","permalink":"/blogs/tags/new-features"},{"inline":true,"label":"message-state","permalink":"/blogs/tags/message-state"},{"inline":true,"label":"message-checksum","permalink":"/blogs/tags/message-checksum"}],"readingTime":4.17,"hasTruncateMarker":true,"authors":[{"name":"Piotr Gankiewicz","title":"Apache Iggy founder","url":"https://github.com/spetz","socials":{},"key":null,"page":null}],"frontMatter":{"title":"Message state","slug":"message-state","authors":[{"name":"Piotr Gankiewicz","title":"Apache Iggy founder","url":"https://github.com/spetz"}],"tags":["new-features","message-state","message-checksum"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Message expiry","permalink":"/blogs/message-expiry"},"nextItem":{"title":"Message headers","permalink":"/blogs/message-headers"}}')},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>h});var n=s(6540);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},8695:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>h,default:()=>c,frontMatter:()=>r,metadata:()=>n,toc:()=>l});var n=s(737),a=s(4848),i=s(8453);const r={title:"Message state",slug:"message-state",authors:[{name:"Piotr Gankiewicz",title:"Apache Iggy founder",url:"https://github.com/spetz"}],tags:["new-features","message-state","message-checksum"],hide_table_of_contents:!1},h=void 0,d={authorsImageUrls:[void 0]},l=[{value:"Breaking changes",id:"breaking-changes",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Structures",id:"structures",level:3},{value:"JSON transport",id:"json-transport",level:3},{value:"Binary transport",id:"binary-transport",level:3}];function o(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["The message state is a simple field which extends the existing ",(0,a.jsx)(t.code,{children:"message"})," and provides a way to define whether the particular message might be consumed by the client or not, depending on its value. Let's briefly discuss the motivation behind this feature, the implementation details and the breaking changes introduced by this release."]}),"\n",(0,a.jsx)(t.h2,{id:"breaking-changes",children:"Breaking changes"}),"\n",(0,a.jsxs)(t.p,{children:["Starting with the commit ",(0,a.jsx)(t.a,{href:"https://github.com/apache/iggy/commit/b07f23db798ffcda7c39650f34547f20137ff725",children:"#b07f23d"})," the breaking changes related to polling the messages by the client have been introduced. The ",(0,a.jsx)(t.code,{children:"Message"})," struct used when invoking ",(0,a.jsx)(t.code,{children:"PollMessage"})," command has been extended with new fields, which results in updated binary schema. The available ",(0,a.jsx)(t.a,{href:"https://crates.io/crates/iggy",children:"iggy crate"})," supports these changes since version 0.0.40."]}),"\n",(0,a.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"state"})," is an additional field added to the ",(0,a.jsx)(t.code,{children:"message"})," struct stored on the server-side, as well as polled by the client, which describes the current state of the message. By default, the message state is set to ",(0,a.jsx)(t.code,{children:"available"})," (`code = 1``, see the possible codes below), meaning that the message is available to be consumed by the client."]}),"\n",(0,a.jsxs)(t.p,{children:["However, the state might have a different value, for example ",(0,a.jsx)(t.code,{children:"marked_for_deletion"})," (to be used by the upcoming retention policy feature), ",(0,a.jsx)(t.code,{children:"poisoned"})," (to be used by the upcoming dead-letter queue feature) etc. In the future releases, the server will also provide a way to change the state of the message (for example to mark it as ",(0,a.jsx)(t.code,{children:"poisoned"})," by the client), as well as filtering the messages by the state."]}),"\n",(0,a.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(t.h3,{id:"structures",children:"Structures"}),"\n",(0,a.jsxs)(t.p,{children:["The new ",(0,a.jsx)(t.code,{children:"MessageState"})," is an enum which defines the possible states of the message. The ",(0,a.jsx)(t.code,{children:"Message"})," struct has been extended with the ",(0,a.jsx)(t.code,{children:"state"})," field, which is an instance of the ",(0,a.jsx)(t.code,{children:"MessageState"})," enum. The ",(0,a.jsx)(t.code,{children:"MessageState"})," enum also provides a method to convert the enum variant to the ",(0,a.jsx)(t.code,{children:"u8"})," value, which is used by the binary schema."]}),"\n",(0,a.jsxs)(t.p,{children:["Additionally, the ",(0,a.jsx)(t.code,{children:"Message"})," struct has been extended with the ",(0,a.jsx)(t.code,{children:"checksum"})," field, which is a ",(0,a.jsx)(t.code,{children:"u32"})," value calculated (",(0,a.jsx)(t.strong,{children:"CRC-32"})," algorithm) from the ",(0,a.jsx)(t.code,{children:"payload"})," field. The checksum is used to verify the integrity of the message, and it's calculated on the server-side when the message is being stored. The client can use the checksum to verify the integrity of the message, and if the checksum doesn't match, the client can request the message again. This property has been there for a long time now, but it hasn't been used by the client so far."]}),"\n",(0,a.jsxs)(t.p,{children:["The server and the client now ",(0,a.jsxs)(t.strong,{children:["share the same ",(0,a.jsx)(t.code,{children:"Message"})," struct"]}),", meaning that the same type is being stored on the disk, as well as returned to the client when polling the messages. The motivation behind this approach, was not only to reduce the amount of code, but more importantly to make it easier to implement the extremely important feature being ",(0,a.jsx)(t.strong,{children:"zero-copy"})," (copy data from disk directly to the network buffer with bypassing the kernel space). This feature is planned to be implemented in the future."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct Message {\n    pub offset: u64,\n    pub state: MessageState,\n    pub timestamp: u64,\n    pub id: u128,\n    pub checksum: u32,\n    pub headers: Option<HashMap<HeaderKey, HeaderValue>>,\n    pub length: u32,\n    pub payload: Bytes\n}\n\npub enum MessageState {\n    Available,\n    Unavailable,\n    Poisoned,\n    MarkedForDeletion\n}\n\nimpl MessageState {\n    pub fn as_code(&self) -> u8 {\n        match self {\n            MessageState::Available => 1,\n            MessageState::Unavailable => 10,\n            MessageState::Poisoned => 20,\n            MessageState::MarkedForDeletion => 30\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"json-transport",children:"JSON transport"}),"\n",(0,a.jsxs)(t.p,{children:["As usual, the JSON transport should be rather easy to implement, as it's just a matter of adding the ",(0,a.jsx)(t.code,{children:"state"})," and ",(0,a.jsx)(t.code,{children:"checksum"})," fields to the ",(0,a.jsx)(t.code,{children:"message"})," object being returned when polling the messages. The ",(0,a.jsx)(t.code,{children:"state"})," returns the underscored string value."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'  {\n    "offset": 0,\n    "state": "available",\n    "timestamp": 1692643862990111,\n    "id": 232071677777564499402827199894559175028,\n    "checksum": 2144931076,\n    "headers": null,\n    "payload": "b3JkZXJzX2RhdGFfMg=="\n  },\n  {\n    "offset": 1,\n    "state": "available",\n    "timestamp": 1692643862990112,\n    "id": 44069423551493178892268378627901876657,\n    "checksum": 148782482,\n    "headers": {\n      "key_3": {\n        "kind": "uint64",\n        "value": "QOIBAAAAAAA="\n      },\n      "key 1": {\n        "kind": "string",\n        "value": "dmFsdWUx"\n      },\n      "key-2": {\n        "kind": "bool",\n        "value": "AQ=="\n      }\n    },\n    "payload": "b3JkZXJzX2RhdGFfMw=="\n  }\n'})}),"\n",(0,a.jsx)(t.h3,{id:"binary-transport",children:"Binary transport"}),"\n",(0,a.jsxs)(t.p,{children:["Next, let's take a look at the binary transport. The ",(0,a.jsx)(t.code,{children:"Message"})," struct has been extended with the ",(0,a.jsx)(t.code,{children:"state"})," and ",(0,a.jsx)(t.code,{children:"checksum"})," fields, which results in the updated binary schema. Previously, the ",(0,a.jsx)(t.code,{children:"message"})," struct was defined as follows:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct Message {\n    pub offset: u64,\n    pub timestamp: u64,\n    pub id: u128,\n    pub headers: Option<HashMap<HeaderKey, HeaderValue>>,\n    pub length: u32,\n    pub payload: Bytes\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"And the serialization was:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Offset (8 bytes) + Timestamp (8 bytes) + ID (16 bytes) + Headers (N bytes) + Length (4 bytes) + Payload (`Length` bytes)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Now, the ",(0,a.jsx)(t.code,{children:"message"})," looks like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct Message {\n    pub offset: u64,\n    pub state: MessageState,\n    pub timestamp: u64,\n    pub id: u128,\n    pub checksum: u32,\n    pub headers: Option<HashMap<HeaderKey, HeaderValue>>,\n    pub length: u32,\n    pub payload: Bytes\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"And the serialization has changed to:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Offset (8 bytes) + State (1 byte) + Timestamp (8 bytes) + ID (16 bytes) + Checksum (4 bytes) + Headers (N bytes) + Length (4 bytes) + Payload (`Length` bytes)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["And that's it - simply (de)serialize the ",(0,a.jsx)(t.code,{children:"state"})," field right after the ",(0,a.jsx)(t.code,{children:"offset"})," field, and the ",(0,a.jsx)(t.code,{children:"checksum"})," field right after the ",(0,a.jsx)(t.code,{children:"id"})," field."]})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);