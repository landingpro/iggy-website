"use strict";(self.webpackChunkiggy_website=self.webpackChunkiggy_website||[]).push([[3067],{3513:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"introduction/introduction-high-level-sdk","title":"High-level SDK","description":"If you\'ve read through the getting started guide, you might have noticed that it\'s quite verbose and requires a lot of boilerplate code to get started. This is where the High-level SDK comes in, as it does provide a more user-friendly interface to interact with the Iggy API for both, producer and consumer. Let\'s consider the following features:","source":"@site/docs/introduction/high_level_sdk.md","sourceDirName":"introduction","slug":"/introduction/high-level-sdk","permalink":"/docs/introduction/high-level-sdk","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"introduction-high-level-sdk","slug":"/introduction/high-level-sdk","title":"High-level SDK","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Getting started","permalink":"/docs/introduction/getting-started"},"next":{"title":"Stream Builder","permalink":"/docs/introduction/stream-builder"}}');var s=n(4848),o=n(8453);const r={id:"introduction-high-level-sdk",slug:"/introduction/high-level-sdk",title:"High-level SDK",sidebar_position:4},c=void 0,a={},l=[{value:"Connection string",id:"connection-string",level:2},{value:"Producer",id:"producer",level:2},{value:"Consumer",id:"consumer",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["If you've read through the ",(0,s.jsx)(t.a,{href:"/introduction/getting-started",children:"getting started"})," guide, you might have noticed that it's quite verbose and requires a lot of boilerplate code to get started. This is where the High-level SDK comes in, as it does provide a more user-friendly interface to interact with the Iggy API for both, producer and consumer. Let's consider the following features:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Automatically creating & joining the consumer groups"}),"\n",(0,s.jsx)(t.li,{children:"Committing the offset depending on the particular mode (e.g. in the background based on some interval, after polling N messages etc.)"}),"\n",(0,s.jsx)(t.li,{children:"Batching the messages, whether it's about producing or consuming"}),"\n",(0,s.jsx)(t.li,{children:"Processing the messages as if the stream was an async iterator"}),"\n",(0,s.jsx)(t.li,{children:"Reusing the same client for both, producing and consuming on the same topic without repeating the configuration"}),"\n",(0,s.jsx)(t.li,{children:"And more..."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"connection-string",children:"Connection string"}),"\n",(0,s.jsx)(t.p,{children:"Instead of providing the configuration for the client, you can use the connection string. It's a string that contains all the necessary information to connect to the Iggy API with only a single caveat, as it does support TCP protocol only for now. Here's the basic example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"iggy://iggy:secret@localhost:3050\n"})}),"\n",(0,s.jsx)(t.p,{children:"Which can be used to create the client like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'let client = IggyClient::from_connection_string("iggy://iggy:secret@localhost:3050")?;\n'})}),"\n",(0,s.jsx)(t.p,{children:"And here's the full example with its all optional parts:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"iggy://iggy:secret@localhost:3050?tls=true&tls_domain=test.com&reconnection_retries=5&reconnection_interval=5s&reestablish_after=10s&heartbeat_interval=3s\n"})}),"\n",(0,s.jsx)(t.p,{children:"By default, the connection string is parsed with the following options:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"tls"})," - whether to use the TLS connection or not (default: ",(0,s.jsx)(t.code,{children:"false"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"tls_domain"})," - the domain to use for the TLS connection (default: ",(0,s.jsx)(t.code,{children:"None"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"reconnection_retries"})," - the number of retries to establish the connection (default: ",(0,s.jsx)(t.code,{children:"unlimited"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"reconnection_interval"})," - the interval between the reconnection attempts (default: ",(0,s.jsx)(t.code,{children:"1s"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"reestablish_after"})," - the time to wait before reestablishing the connection (default: ",(0,s.jsx)(t.code,{children:"5s"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"heartbeat_interval"})," - the interval between the heartbeat messages (default: ",(0,s.jsx)(t.code,{children:"5s"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Unless you need to provide a specific implementation of the client-side ",(0,s.jsx)(t.code,{children:"Encryptor"}),", ",(0,s.jsx)(t.code,{children:"Partitioner"})," or adjust some other settings, you should be good to go with the connection string. On the other hand, you can always make use of ",(0,s.jsx)(t.code,{children:"IggyClientBuilder::from_connection_string()"})," to extend the options on top of the provided connection string."]}),"\n",(0,s.jsxs)(t.p,{children:["Additionally, if you were to check the internal implementation of ",(0,s.jsx)(t.code,{children:"IggyClient"}),", you'd notice that it does use ",(0,s.jsx)(t.code,{children:"IggySharedMut<>"})," which means that you can use a single instance of the client across multiple threads. Typically, it's a good idea to create a separate connection for producing and consuming, but it's not a requirement."]}),"\n",(0,s.jsx)(t.h2,{id:"producer",children:"Producer"}),"\n",(0,s.jsxs)(t.p,{children:["The producer is a high-level abstraction that allows you to send messages to the topic. It's quite simple to use and doesn't require you to handle the offsets, partitions or any other low-level details. To begin with, you can simply invoke ",(0,s.jsx)(t.code,{children:"client.producer()"})," to get the ",(0,s.jsx)(t.code,{children:"IggyProducerBuilder"})," allowing you to configure the producer. Let's take a look at the basic example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'let mut producer = client\n    .producer("my-stream", "my-topic")?\n    .batch_size(1000)\n    .send_interval(IggyDuration::from_str("5ms")?)\n    .partitioning(Partitioning::balanced())\n    .build();\nproducer.init().await?;\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The code above will result in creating the producer that will try to send the messages in batches of 1000 every 5 milliseconds. The partitioning is set to ",(0,s.jsx)(t.code,{children:"balanced"})," which means that the producer will try to distribute the messages evenly across all the partitions. The ",(0,s.jsx)(t.code,{children:"init()"})," method is used to ensure that the producer is ready to send the messages by validating the existence of the stream, topic etc."]}),"\n",(0,s.jsxs)(t.p,{children:["Finally, you can use the ",(0,s.jsx)(t.code,{children:"send()"})," method to send the messages to the topic. The producer doesn't need to be a mutable reference, as it's only required during the initialization phase. Here's how you can send the messages:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'let messages = vec![Message::from_str("hello")?, Message::from_str("world")?];\nproducer.send(messages).await?\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Of course, you can provide the message headers, custom binary serialization etc. as it's the same ",(0,s.jsx)(t.code,{children:"Message"})," struct as the one used in the low-level API. The producer will take care of the rest, including the retries, partitioning, batching etc."]}),"\n",(0,s.jsx)(t.h2,{id:"consumer",children:"Consumer"}),"\n",(0,s.jsxs)(t.p,{children:["The consumer is a high-level abstraction that allows you to receive the messages from the topic. It's quite simple to use and doesn't require you to handle the offsets, partitions or any other low-level details. To begin with, you can simply invoke ",(0,s.jsx)(t.code,{children:"client.consumer()"})," to get the ",(0,s.jsx)(t.code,{children:"IggyConsumerBuilder"})," allowing you to configure the consumer. Let's take a look at the basic example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'let mut consumer = client\n    .consumer_group("my-consumer-group", "my-stream", "my-topic")?\n    .auto_commit(AutoCommit::IntervalOrWhen(\n        IggyDuration::from_str("1s")?,\n        AutoCommitWhen::ConsumingAllMessages,\n    ))\n    .create_consumer_group_if_not_exists()\n    .auto_join_consumer_group()\n    .polling_strategy(PollingStrategy::next())\n    .poll_interval(IggyDuration::from_str("1ms")?)\n    .batch_size(1000)\n    .build();\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The code above will result in creating the consumer that will try to consume the messages in batches of 1000 every 1 millisecond. The auto-commit is set to commit the offset every second or when all the messages are consumed (fetched). The polling strategy is set to ",(0,s.jsx)(t.code,{children:"next"})," which means that the consumer will try to consume the next available message from the partition currently assigned to the consumer group (you can also invoke a regular ",(0,s.jsx)(t.code,{children:"consumer()"})," builder if you do not plan to use the consumer groups). The ",(0,s.jsx)(t.code,{children:"build()"})," method is used to create the consumer."]}),"\n",(0,s.jsxs)(t.p,{children:["Finally, you can use the ",(0,s.jsx)(t.code,{children:"next()"})," method to receive the messages from the topic. The consumer doesn't need to be a mutable reference, as it's only required during the initialization phase. Here's how you can consume the messages:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"consumer.init().await?;\n\n// Start consuming the messages\nwhile let Some(message) = consumer.next().await {\n    // Handle the message\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In order to use the async iterator extension, add ",(0,s.jsx)(t.a,{href:"https://crates.io/crates/futures-util",children:"futures-util"})," dependency."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);