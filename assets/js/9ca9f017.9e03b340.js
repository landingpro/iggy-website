"use strict";(self.webpackChunkiggy_website=self.webpackChunkiggy_website||[]).push([[8895],{2842:(e,t,i)=>{i.d(t,{A:()=>s});const s=i.p+"assets/images/architecture-5d7f7f7ed58a399ea2f5a7c74c074f65.png"},6561:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"introduction/introduction-architecture","title":"Architecture","description":"Iggy is the persistent message streaming, which means, that the messages are being stored in a form of an append-only log. You can create multiple streams, consisting of topics, which might have one or more partitions assigned, e.g. to achieve the horizontal scalability between many independent consumers or higher system resiliency. You can think of Iggy as an alternative to Kafka or RabbitMQ streams.","source":"@site/docs/introduction/architecture.md","sourceDirName":"introduction","slug":"/introduction/architecture","permalink":"/docs/introduction/architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"introduction-architecture","slug":"/introduction/architecture","title":"Architecture","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"About","permalink":"/docs/introduction/about"},"next":{"title":"Getting started","permalink":"/docs/introduction/getting-started"}}');var n=i(4848),a=i(8453);const r={id:"introduction-architecture",slug:"/introduction/architecture",title:"Architecture",sidebar_position:2},o=void 0,h={},c=[{value:"Message streaming",id:"message-streaming",level:2},{value:"Append-only log",id:"append-only-log",level:2},{value:"Stream",id:"stream",level:2},{value:"Topic",id:"topic",level:2},{value:"Partition",id:"partition",level:2},{value:"Segment",id:"segment",level:2},{value:"Structure",id:"structure",level:2}];function d(e){const t={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Iggy is the persistent message streaming, which means, that the messages are being stored in a form of an append-only log. You can create multiple streams, consisting of topics, which might have one or more partitions assigned, e.g. to achieve the horizontal scalability between many independent consumers or higher system resiliency. You can think of Iggy as an alternative to Kafka or RabbitMQ streams."}),"\n",(0,n.jsx)(t.p,{children:"Let's discuss in-depth what these concepts are all about and how they relate to each other."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Architecture",src:i(2842).A+"",width:"6000",height:"3375"})}),"\n",(0,n.jsx)(t.h2,{id:"message-streaming",children:"Message streaming"}),"\n",(0,n.jsx)(t.p,{children:"There's a high chance that you've already used messaging tools such as RabbitMQ or Kafka, just to name a few. While they might look similar at the first glance, and actually, you can achieve the similar results with all of them (e.g. publishing and consuming the events by the different applications built on top of microservices architecture), they are quite different in their core."}),"\n",(0,n.jsx)(t.p,{children:"The main difference is that RabbitMQ (except the recently released Streams plugin) is the message broker, which means that it's responsible for delivering the messages to the consumers. It works in the FIFO (First In, First Out) manner and the messages are being kept in the queues. For example, if you have multiple, distinct consumers, then each one would create its own queue, the message would be replicated between each queue and each consumer would be responsible for reading the messages from its own queue. Once the message is processed, it's gone from the queue, so there's no built-in way to replay past the messages. The more consumers you have, the more queues you have to create, which might result in more resources being used. The typical message broker follows the so-called smart pipes and dumb endpoints pattern."}),"\n",(0,n.jsx)(t.p,{children:"On the other hand, Kafka is a message streaming platform, meaning that it's not responsible for delivering the messages to the consumers, but rather it's storing them in a form of an append-only log. The consumers are responsible for reading the messages from the log and processing them. You might have multiple distinct consumers, and it doesn't affect the resource usage as there's only one log. The consumers can read the messages from the beginning, or from the specific offset, thus you can replay the messages. The typical message streaming platform follows the so-called dumb pipes and smart endpoints pattern."}),"\n",(0,n.jsx)(t.p,{children:"There are advantages and disadvantages of both approaches, but the main difference is that the message broker is responsible for delivering the messages to the consumers, while the message streaming platform is not. The message broker is a more mature concept, but the message streaming platform is gaining more and more popularity, especially in the cloud-native world. And you can achieve much higher performance and throughput with the message streaming platform, since it acts as a simple database, being optimized for the append-only operations and can be queried in a very efficient way."}),"\n",(0,n.jsx)(t.p,{children:"As you might've guessed by now, Iggy is the latter - the message streaming platform."}),"\n",(0,n.jsx)(t.h2,{id:"append-only-log",children:"Append-only log"}),"\n",(0,n.jsx)(t.p,{children:"The append-only log is the core concept of Iggy. It's a simple data structure, which is optimized for the append-only operations. It's a sequence of records, that are being appended to the end of the log. The records are immutable, so that they can't be changed once they are written to the log. The records are being written in the order they are received, which results in the log being is ordered."}),"\n",(0,n.jsx)(t.p,{children:"To navigate the log, you can use the offset, which is the position of the record in the log. The offset is a simple integer, that starts from 0 and is incremented by 1 for each record. When the client is reading the records from the log, it can specify the offset from which it wants to start reading the records. The client can also specify the maximum number of records it wants to read. The client can read the records from the beginning, or from the specific offset, which means that you can replay the messages."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"+-------------------------------------------------------+\n|                  Append-Only Log                      |\n+-------------------------------------------------------+\n| Message1  | Message2 | Message3 | Message4 | Message5 |\n| --------  | -------- | -------- | -------- | -------- |\n| Offset=0  | Offset=1 | Offset=2 | Offset=3 | Offset=4 |\n+-------------------------------------------------------+\n"})}),"\n",(0,n.jsx)(t.h2,{id:"stream",children:"Stream"}),"\n",(0,n.jsxs)(t.p,{children:["While we could put an equal sign between the log and the stream, they are not the same, at least in a case of Iggy streaming server.\nThe stream is a logical concept, and you might think of it as a namespace. For example, you could have a single stream for the whole system, or multiple streams e.g. representing the different environments, such as ",(0,n.jsx)(t.code,{children:"dev"}),", ",(0,n.jsx)(t.code,{children:"staging"})," and ",(0,n.jsx)(t.code,{children:"production"}),". The stream is identified by its unique ID. The stream can have one or more topics assigned, which results in the records being published to the specific topics that belong to the particular stream."]}),"\n",(0,n.jsx)(t.h2,{id:"topic",children:"Topic"}),"\n",(0,n.jsx)(t.p,{children:"The topic is also the logical concept, which is a part of the stream. The topic is identified by its unique ID. You could think of topic as an entity being responsible for storing the specific type of the records. For example, you could have a topic for the user events, and another topic for the order events, etc."}),"\n",(0,n.jsx)(t.p,{children:"The important thing to note is that, the messages are not being stored in the topic directly, but rather in the partitions, which are assigned to the topic. The topic can have one or more partitions assigned, that could help achieve higher parallelism and throughput. The topic can also have the retention policy assigned, which means that the records are being deleted automatically once they are older than the specified retention period."}),"\n",(0,n.jsx)(t.h2,{id:"partition",children:"Partition"}),"\n",(0,n.jsx)(t.p,{children:"The partition has its own unique ID and belongs to the topic. The partition is responsible for storing the records. The records are being distributed between the partitions, therefore the partition acts as a simple database, which is optimized for the append-only operations. The partition is identified by its unique ID, which is an integer. The partition ID starts from 1 and is incremented by 1 for each partition. The partition ID is unique per topic, thus the same partition ID can be used in multiple topics."}),"\n",(0,n.jsx)(t.p,{children:"Thanks to having multiple partitions, we can achieve the horizontal scalability between many independent consumers, since each consumer can read the messages from the different partitions. This can be achieved by using more advanced concepts such as consumer groups."}),"\n",(0,n.jsx)(t.h2,{id:"segment",children:"Segment"}),"\n",(0,n.jsx)(t.p,{children:"The segment, being a part of the partition, is the actual physical layer which stores the records in the binary format in a form of the files. Each segment has the limited size (e.g. 1 GB) and once it's full, the new segment is being created automatically. The segment name is based on the start offset of the first record in the segment and is unique per partition."}),"\n",(0,n.jsx)(t.h2,{id:"structure",children:"Structure"}),"\n",(0,n.jsx)(t.p,{children:"Having in mind that stream consists of topics, which might have one or more partitions assigned, and each partition consists of segments, we can visualize the structure of the Iggy data directory as follows:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"streams\n\u2514\u2500\u2500 1\n    \u2514\u2500\u2500 topics\n        \u2514\u2500\u2500 1\n            \u251c\u2500\u2500 partitions\n            \u2502             \u2514\u2500\u2500 1\n            \u2502                 \u251c\u2500\u2500 00000000000000000000.index\n            \u2502                 \u251c\u2500\u2500 00000000000000000000.log\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The additional ",(0,n.jsx)(t.code,{children:".index"})," file is being created automatically and are being used to speed up the search operations by keeping track of the offsets and timestamps of the records."]})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var s=i(6540);const n={},a=s.createContext(n);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);